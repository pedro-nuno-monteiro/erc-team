{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s6\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs12\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\*\listtable
{\list\listtemplateid1
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8226 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u8662 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9702 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9642 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid1}
{\list\listtemplateid2
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9744 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid2}
{\list\listtemplateid3
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li360 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li720 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1080 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1440 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li1800 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2160 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2520 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li2880 }
{ \listlevel\levelnfc23\leveljc0\levelstartat1\levelfollow0{\leveltext \'01\u9746 ?;}{\levelnumbers;}\f8\dbch\af3\fi-360\li3600 }
\listid3}
}
{\listoverridetable
{\listoverride\listid1\listoverridecount0\ls1}
{\listoverride\listid2\listoverridecount0\ls2}
{\listoverride\listid3\listoverridecount0\ls3}
}
{\info 
{\title {\comment Documenta\'E7\'E3o  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3.0 \par
}}Documenta\'E7\'E3o}
{\comment Generated by doxygen 1.12.0.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt Documenta\'E7\'E3o}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 3.0\par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Documenta\'E7\'E3o\par \pard\plain 
{\tc\tcl1 \v Documenta\'E7\'E3o}
{\xe \v Documenta\'E7\'E3o}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code taken from Simulation and Modelling 5e, Averill M. Law B with some modifications\par
This code simulates a singe server queue (FIFO) - M/M/n/\\infity, where where:{
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
m: Markovian (Poisson) arrival process,\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
m: Exponential service time distribution,\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
1: A single server,\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u8226\tab}\ilvl0\ls1 \li0\ri0\lin0\rin0\fi-360\tx360\li360\ri0\lin360\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
\\infty: Infinite queue capacity.\par}
\par
This simulation requires an input file {\f2 mm1in.txt}  containing three parameters:{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Mean interarrival time,\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Mean service time,\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Number of customers to be delayed.\par}
\par
The simulation outputs the results to a file {\f2 mm1out.txt} . \par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Index\par \pard\plain 
{\tc \v Data Structure Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Data Structures\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the data structures with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b EventList} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that keeps track of event timing functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Files} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure with file pointers for input and output op })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Statistics} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that holds statistics for time-average calculations })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SystemState} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that represents the system state })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b lab1/{\b fila1s.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lab1/{\b fila1s.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for simulation and modelling })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lab1/{\b lcgrand.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lab1/{\b lcgrand.h} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for the random number generator functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b lab1/{\b simula_fila1s.c} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Data Structure Documentation{\tc \v Data Structure Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EventList Struct Reference\par \pard\plain 
{\tc\tcl2 \v EventList}
{\xe \v EventList}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that keeps track of event timing functions. }}\par
{
{\f2 #include <fila1s.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b sim_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b time_last_event}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b time_next_event} [{\b MAX_SERVERS}+2]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that keeps track of event timing functions. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v sim_time\:EventList}
{\xe \v EventList\:sim_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float sim_time}}
\par
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Simulation time. \par
}}
{\xe \v time_last_event\:EventList}
{\xe \v EventList\:time_last_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float time_last_event}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time of the last event. \par
}}
{\xe \v time_next_event\:EventList}
{\xe \v EventList\:time_next_event}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float time_next_event[{\b MAX_SERVERS}+2]}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Scheduled times for the next events. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lab1/{\b fila1s.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Files Struct Reference\par \pard\plain 
{\tc\tcl2 \v Files}
{\xe \v Files}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure with file pointers for input and output op. }}\par
{
{\f2 #include <fila1s.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b infile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
FILE * {\b outfile}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure with file pointers for input and output op. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v infile\:Files}
{\xe \v Files\:infile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* infile}}
\par
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Input file pointer for reading data. \par
}}
{\xe \v outfile\:Files}
{\xe \v Files\:outfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FILE* outfile}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output file pointer for storing/writing results. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lab1/{\b fila1s.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Statistics Struct Reference\par \pard\plain 
{\tc\tcl2 \v Statistics}
{\xe \v Statistics}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that holds statistics for time-average calculations. }}\par
{
{\f2 #include <fila1s.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b area_num_in_q}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b area_server_status} [{\b MAX_SERVERS}+2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b total_of_delays}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lost_customers}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that holds statistics for time-average calculations. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v area_num_in_q\:Statistics}
{\xe \v Statistics\:area_num_in_q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float area_num_in_q}}
\par
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cumulative area under the number-in-queue function. \par
}}
{\xe \v area_server_status\:Statistics}
{\xe \v Statistics\:area_server_status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float area_server_status[{\b MAX_SERVERS}+2]}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Cumulative area under the server-status function (busy or idle). \par
}}
{\xe \v lost_customers\:Statistics}
{\xe \v Statistics\:lost_customers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int lost_customers}}
\par
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v total_of_delays\:Statistics}
{\xe \v Statistics\:total_of_delays}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float total_of_delays}}
\par
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total amount of delay. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lab1/{\b fila1s.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SystemState Struct Reference\par \pard\plain 
{\tc\tcl2 \v SystemState}
{\xe \v SystemState}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that represents the system state. }}\par
{
{\f2 #include <fila1s.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Fields\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b next_event_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_custs_delayed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_delays_required}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_in_q}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b server_status} [{\b MAX_SERVERS}+2]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b time_arrival} [{\b Q_LIMIT}+1]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b mean_interarrival}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b mean_service}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b number_of_servers}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_events}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b streams} [{\b MAX_SERVERS}+1]\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b without_infinite_queue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b A}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that represents the system state. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Field Documentation\par
\pard\plain 
{\xe \v A\:SystemState}
{\xe \v SystemState\:A}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float A}}
\par
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v mean_interarrival\:SystemState}
{\xe \v SystemState\:mean_interarrival}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float mean_interarrival}}
\par
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mean time between customer arrivals (inter-arrival time). \par
}}
{\xe \v mean_service\:SystemState}
{\xe \v SystemState\:mean_service}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float mean_service}}
\par
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mean service time. \par
}}
{\xe \v next_event_type\:SystemState}
{\xe \v SystemState\:next_event_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int next_event_type}}
\par
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Type of the next event to occur (e.g., arrival, departure). \par
}}
{\xe \v num_custs_delayed\:SystemState}
{\xe \v SystemState\:num_custs_delayed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int num_custs_delayed}}
\par
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of customers that have been delayed. \par
}}
{\xe \v num_delays_required\:SystemState}
{\xe \v SystemState\:num_delays_required}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int num_delays_required}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of delays required to complete the simulation. \par
}}
{\xe \v num_events\:SystemState}
{\xe \v SystemState\:num_events}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int num_events}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Antes era um numero fixo, mas agora \'E9 dinamico pois depende do numero de servers. \par
}}
{\xe \v num_in_q\:SystemState}
{\xe \v SystemState\:num_in_q}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int num_in_q}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Number of customers in the queue. \par
}}
{\xe \v number_of_servers\:SystemState}
{\xe \v SystemState\:number_of_servers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int number_of_servers}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v server_status\:SystemState}
{\xe \v SystemState\:server_status}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int server_status[{\b MAX_SERVERS}+2]}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Server status (0 = idle, 1 = busy). \par
}}
{\xe \v streams\:SystemState}
{\xe \v SystemState\:streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int streams[{\b MAX_SERVERS}+1]}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time_arrival\:SystemState}
{\xe \v SystemState\:time_arrival}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float time_arrival[{\b Q_LIMIT}+1]}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Time of arrival for each customer in the queue. \par
}}
{\xe \v without_infinite_queue\:SystemState}
{\xe \v SystemState\:without_infinite_queue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int without_infinite_queue}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
lab1/{\b fila1s.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lab1/fila1s.c File Reference\par \pard\plain 
{\tc\tcl2 \v lab1/fila1s.c}
{\xe \v lab1/fila1s.c}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "fila1s.h"}\par
{\f2 #include "lcgrand.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ask_streams} ({\b SystemState} *state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generate_other_streams} ({\b SystemState} *state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b selectFreeServer} ({\b SystemState} *state, {\b Statistics} *stats)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b expon} (float mean, int stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events, int stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b report} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update_time_avg_stats} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update area accumulators for time-average statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b timing} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b arrive} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depart} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arrive\:fila1s.c}
{\xe \v fila1s.c\:arrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void arrive ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function arrive : handles customers arriving at the queue by scheduling the next arrival, checking server availability, and managing the queue if all servers are occupied.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to track queue size, server status, and number of lost customers.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, updated to increment lost customers if the queue is full.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure, used for handling queue overflow conditions.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to schedule the next arrival event. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We increased the number of users in the waiting list\par
Check to see whether an overflow condition exists.\par
The queue has overflowed, so stop the simulation.\par
There is still room in the queue, so store the time of arrival of the arriving customer at the (new) end of time_arrival.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 334                                                                                         \{\par
335     \par
336     {\cf18 float} delay;\par
337     \par
338     {\cf20 /* Schedule the next arrival event */}\par
339     events->time_next_event[1] = events->sim_time + expon(state->mean_interarrival,state->streams[0]); \par
340 \par
341     {\cf20 /* Checks if there are free servers, if there are not, the function returns -1 */}\par
342     {\cf18 int} free_server_index = selectFreeServer(state, stats);\par
343 \par
344     {\cf19 if} (free_server_index != -1) \{ {\cf20 /* There are free servers */}\par
345         delay = 0.0; {\cf20 /* The customer is served immediately, so the delay = 0 */}\par
346 \par
347         {\cf20 /* Increases the number of customers served */}\par
348         ++state->num_custs_delayed;\par
349 \par
350         {\cf20 /* Mark the server as busy */}\par
351         state->server_status[free_server_index] = BUSY;\par
352 \par
353         {\cf20 /* Schedule a departure for this customer (service completion) */}\par
354         events->time_next_event[free_server_index] = events->sim_time + expon(state->mean_service, state->streams[free_server_index-1]);\par
355     \}\par
356 \par
357     {\cf19 else}\{ {\cf20 /* Todos os servers estao ocupados */}\par
358 \par
359         {\cf19 if}(state->without_infinite_queue == 0)\{ {\cf20 /* If we don't have a queue -> M/M/n/0 (Erlang-B): Reject customer */}\par
360             stats->lost_customers++;\par
361         \}\par
362 \par
363         {\cf19 else}\{\par
364 \par
365             ++state->num_in_q; \par
366             \par
367 \par
368             {\cf19 if} (state->num_in_q > Q_LIMIT) \{\par
369 \par
370                 fprintf(files->outfile, {\cf22 "\\nOverflow of the array time_arrival at"});\par
371                 fprintf(files->outfile, {\cf22 " time %f"}, events->sim_time);\par
372                 exit(2);\par
373             \}\par
375 \par
376             state->time_arrival[state->num_in_q] = events->sim_time;\par
377 \par
378         \}\par
379     \}\par
380 \}\par
}
}
{\xe \v ask_streams\:fila1s.c}
{\xe \v fila1s.c\:ask_streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ask_streams ({\b SystemState} * state)}}
\par
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code from Simulation and Modelling 5e Averill M. Law B Function ask_streams: prompts the user to enter two seeds, one for arrivals and another for departures. Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->streams[i]: array updated with the first two seeds.\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: pointer to the system state structure where seeds are stored. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                     \{\par
20 \par
21 \par
22     {\cf20 /* We ask for 2 seeds, the first is reserved for arrivals and the second is used for departures */}\par
23     {\cf19 for}({\cf18 int} i = 0; i < 2; i++) \{\par
24             {\cf19 do} \{\par
25                 {\cf19 if}(i==0)\{\par
26                     printf({\cf22 "Escreve a semente correspondente as chegadas: "});\par
27                 \}\par
28                 {\cf19 else}\{\par
29                     printf({\cf22 "Escreve a semente correspondente as partidas: "});\par
30                 \}\par
31                 \par
32                 {\cf19 if} (scanf({\cf22 "%d"}, &state->streams[i]) != 1) \{  \par
33                     printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
34                     {\cf18 int} ch;\par
35                     {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF); \par
36                     state->streams[i] = -1;\par
37                 \}\par
38 \par
39                 {\cf19 if}(state->streams[i] <= 0 || state->streams[i] > 100) \{ {\cf20 /* We guarantee that each seed introduced is within the desired values  */}\par
40                     printf({\cf22 "As sementes t\'EAm de estar compreendidas entre [1, 100]. \\n"});\par
41                 \}\par
42             \} {\cf19 while}(state->streams[i] <= 0 || state->streams[i] > 100 || (i == 1 && state->streams[0] == state->streams[1])); {\cf20 /* This loop ensures that the two seeds are different from each other */}\par
43         \}\par
44 \par
45 \}\par
}
}
{\xe \v depart\:fila1s.c}
{\xe \v fila1s.c\:depart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void depart ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function depart : handles customer departures by updating queue length, calculating delay for the customer beginning service, and setting the server status to idle if the queue is empty.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to track server status, queue length, and customer arrival times.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, updated to accumulate total delay and number of customers delayed.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to schedule the next departure or set it to infinity if the server becomes idle. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the queue is empty\par
The queue is empty so make the server idle and eliminate the departure (service completion) event from consideration.\par
Compute the delay of the customer who is beginning service and update the total delay accumulator.\par
Increment the number of customers delayed, and schedule departure.\par
Move each customer in queue (if any) up one place. With a circular queue it is much better\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 393                                                                       \{\par
394     \par
395     {\cf18 float} delay;\par
396 \par
397 \par
398     {\cf19 if} (state->num_in_q == 0) \{\par
400 \par
401         state->server_status[state->next_event_type] = IDLE; {\cf20 /* The next_event type corresponds to the server index -> see in the timing function */}\par
402         events->time_next_event[state->next_event_type] = 1.0e+30; {\cf20 /* Sets the next event to infinite */}\par
403     \}\par
404     {\cf19 else} \{ {\cf20 /* The queue is not empty */}\par
405         \par
406         {\cf20 /* So the number of customers in the queue decreases */}\par
407         --state->num_in_q;\par
408 \par
409 \par
410         delay = events->sim_time - state->time_arrival[1];\par
411 \par
412         stats->total_of_delays += delay;\par
413 \par
414 \par
415         ++state->num_custs_delayed;\par
416         events->time_next_event[2] = events->sim_time + expon(state->mean_service,state->streams[state->next_event_type]);\par
417 \par
418 \par
419         {\cf19 for} ({\cf18 int} i = 1; i <= state->num_in_q; ++i)\par
420             state->time_arrival[i] = state->time_arrival[i + 1];\par
421     \}\par
422 \par
423 \}\par
}
}
{\xe \v expon\:fila1s.c}
{\xe \v fila1s.c\:expon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float expon (float mean, int stream)}}
\par
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function expon: calculates an exponentially distributed random variable.\par
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
mean: mean of the exponential distribution\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: seed for random number generation.\par}
Returns: an exponentially distributed value with the specified mean. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 140                                     \{\par
141     {\cf19 return} -mean * logf(lcgrand(stream));\par
142 \}\par
}
}
{\xe \v generate_other_streams\:fila1s.c}
{\xe \v fila1s.c\:generate_other_streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void generate_other_streams ({\b SystemState} * state)}}
\par
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function generate_other_streams: generates additional seed streams for servers.\par
Input/output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->streams: array updated with generated seeds\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: structure containing the number of servers. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                                \{\par
59 \par
60     {\cf20 /* This function generates the remaining seeds used. If there are n servers then we need to generate n-1 seeds because the first seed corresponding to arrival is used for the first server. */}\par
61 \par
62     {\cf20 /* This loop serves to ensure that the seeds now generated are not the same as the seed used by the arrival.}\par
63 {\cf20     Furthermore, it guarantees that seed generation is circular, that is, if we reach index 1001 it becomes 1. }\par
64 {\cf20     Seeds are generated from the starting seed for server 1 and the rest are obtained by adding 1 unit. */}\par
65 \par
66     {\cf19 for}({\cf18 int} i= 2; i<=state->number_of_servers + 1; i++)\{\par
67         state->streams[i] = state->streams[i-1] + 1; \par
68         {\cf19 if}(state->streams[i] == state->streams[0])\{\par
69             state->streams[i] = state->streams[i-1] + 2;\par
70         \}\par
71         {\cf19 if} (state->streams[i] == 101) \{\par
72             state->streams[i] = 1;\par
73         \}   \par
74     \}\par
75 \par
76     printf({\cf22 "Streams = [ "});\par
77 \par
78     {\cf20 /* This loop is only used to show the array with all the seeds that will be used */}\par
79     {\cf19 for}({\cf18 int} i=0; i<=state->number_of_servers + 1 ; i++)\{\par
80         {\cf19 if}(i < state->number_of_servers+1)\{\par
81             printf({\cf22 " %d, "}, state->streams[i]);\par
82         \}\par
83         {\cf19 else}\{\par
84             printf({\cf22 " %d ] \\n"}, state->streams[i]);\par
85         \}\par
86     \}\par
87 \par
88 \}\par
}
}
{\xe \v initialize\:fila1s.c}
{\xe \v fila1s.c\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void initialize ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events, int stream)}}
\par
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function initialize: initializes the state of the simulation system, including setting up the simulation clock, random number generators, state variables, and event list\par
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: Random number stream used for generating arrival times.\par}
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: Random number stream used for generating arrival times. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the simulation clock.\par
These are the departures for each server. We put a big number.\par
Update the number of events\par
Number of custumers in queu start in zero\par
Initialize the statistical counters.\par
Initialize event list. Since no customers are present, the departure (service completion) event is eliminated from consideration.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 160                                                                                          \{\par
161     \par
162     events->sim_time = 0.0; \par
163 \par
164 \par
165     events->time_next_event[1] = events->sim_time + expon(state->mean_interarrival, stream); {\cf20 /* time_next_event[1] representa o evento de chegada*/}\par
166     {\cf20 // events->time_next_event[2] = 1.0e+30;}\par
167 \par
168     {\cf20 /* Initialize all servers as IDLE */}\par
169     {\cf20 /* Initialize departure events for each server */}\par
170     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; ++i) \{\par
171         state->server_status[i] = IDLE;\par
172         stats->area_server_status[i] = 0.0;\par
173         {\cf20 /* We use i+2 here because we start at [2] since position [1] is for the arrival event */}\par
174         events->time_next_event[i] = 1.0e+30; \par
175     \}\par
176 \par
177 \par
178     state->num_events=state->number_of_servers+1 ; \par
179 \par
180     state->num_in_q = 0; \par
181     events->time_last_event = 0.0; {\cf20 /* Time of last event starts in zero */}\par
182 \par
183     state->num_custs_delayed =   0; {\cf20 /* Number of custumers */}\par
184     stats->total_of_delays   =   0.0; {\cf20 /* Number of delays */}\par
185     stats->area_num_in_q     =   0.0; {\cf20 /* Number of the utilization rate */}\par
186     stats->lost_customers    =   0; {\cf20 /* Number of lost costumers */}\par
188 \par
189     \par
190 \}\par
}
}
{\xe \v report\:fila1s.c}
{\xe \v fila1s.c\:report}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void report ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function report: writes the simulation results to the output file, including performance metrics like average delay, lost customers, and server utilization.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure.\par}
Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Writes the formatted simulation report to the output file. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write report heading and input parameters to the output file.\par
Print the average delay in queue per client\par
Print the average number of lost clients\par
Print the average number of clients in queue\par
Print the average server utilization. We use this loop to ensure that if area_server_status == 0 then we avoid divisions by zero\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 207                                                                                         \{\par
208 \par
209 \par
210     fprintf(files->outfile, {\cf22 "Single-server queueing system\\n\\n"});\par
211     fprintf(files->outfile, {\cf22 "Mean interarrival time%11.3f minutes\\n\\n"}, state->mean_interarrival);\par
212     fprintf(files->outfile, {\cf22 "Mean service time%16.3f minutes\\n\\n"}, state->mean_service);\par
213     fprintf(files->outfile, {\cf22 "Number of customers%14d\\n\\n"}, state->num_delays_required);\par
214     {\cf19 if}(state->without_infinite_queue == 0 )\{\par
215         fprintf(files->outfile, {\cf22 "Without Queue\\n\\n"});\par
216     \}\par
217     {\cf19 else}\{\par
218         fprintf(files->outfile, {\cf22 "With Queue\\n\\n"});\par
219     \}\par
220     \par
221 \par
222 \par
223     fprintf(files->outfile, {\cf22 "\\n\\nAverage delay in queue per client %11.3f minutes\\n\\n"}, stats->total_of_delays / state->num_custs_delayed);\par
224 \par
225     {\cf19 if}(state->without_infinite_queue == 0)\{  {\cf20 /* If we don't have an infinite queue */}\par
226 \par
227         fprintf(files->outfile, {\cf22 "Average number of lost clients %14.3f\\n\\n"}, stats->lost_customers);\par
228     \}\par
229 \par
230     {\cf19 else}\{ {\cf20 /* If we have an infinite queue */}\par
231 \par
232         fprintf(files->outfile, {\cf22 "Average number of clients in queue %10.3f\\n\\n"}, stats->area_num_in_q / events->sim_time);\par
233     \}\par
234     \par
235 \par
237 \par
238     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; i++ )\{\par
239         {\cf19 if} (events->sim_time > 0) \{\par
240             fprintf(files->outfile, {\cf22 "Server %d utilization%25.3f\\n\\n"}, i-1 ,stats->area_server_status[i] / events->sim_time);\par
241          \} \par
242          \par
243         {\cf19 else} \{ {\cf20 /* To avoid division by zero if events->sim_time > 0 */}\par
244             fprintf(files->outfile, {\cf22 "Server %d utilization%25.3f \\n\\n"}, i-1, 0.0);\par
245         \}\par
246     \}\par
247 \par
248 \par
249     fprintf(files->outfile, {\cf22 "Time simulation ended%26.3f minutes"}, events->sim_time);\par
250 \}\par
}
}
{\xe \v selectFreeServer\:fila1s.c}
{\xe \v fila1s.c\:selectFreeServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int selectFreeServer ({\b SystemState} * state, {\b Statistics} * stats)}}
\par
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function selectFreeServer: selects an available server based on the area of each server.\par
Output parameters: index of the available server or -1 if all are busy.\par
Input/output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats->area_server_status: indicates the area of each server.\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->server_status: array with the status (IDLE/BUSY) of each server. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                                                               \{ \par
104     \par
105     {\cf18 int} livre = -1; {\cf20 /* At the beginning we assume that no server is IDLE */}\par
106     {\cf18 int} aux = stats->area_server_status[2]; {\cf20 /* Let's assume that the first server is the one with the lowest utilization rate */} \par
107     {\cf18 int} indice = 2; {\cf20 /* We assume that the first server (index = 2) is the one with the lowest utilization rate */}\par
108 \par
109     {\cf20 /* This loop serves to understand which server has the lowest usage rate and is at the same time free */}\par
110     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers+1; ++i) \{\par
111         {\cf19 if} (state->server_status[i] == IDLE) \{\par
112             livre = 1; {\cf20 /* There is at least one free server */}\par
113             {\cf19 if}(stats->area_server_status[i]<=aux)\{\par
114                 aux = stats->area_server_status[i];\par
115                 indice = i; \par
116             \}\par
117             \par
118         \}\par
119     \}\par
120     {\cf19 if} (livre == -1)\{\par
121         {\cf19 return} -1; {\cf20 /* returns -1 if all servers are busy */}\par
122     \}\par
123     {\cf19 else}\{\par
124         {\cf19 return} indice; {\cf20 /* returns the index of the first available server */}\par
125     \}\par
126     \par
127 \}\par
}
}
{\xe \v timing\:fila1s.c}
{\xe \v fila1s.c\:timing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void timing ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function timing : determines the next event based on the times stored in the event list. Advances the simulation clock to the time of the next event. Checks if the event list is empty; if so, the simulation terminates.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to set the next event type.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, used here only for access to simulation variables.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure, used for writing termination messages if the event list is empty.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to set the simulation time to the time of the next event. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function loops through all event types and checks the time of each stored event. The event with the shortest time is the next to happen\par
Check to see whether the event list is empty.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 294                                                                                         \{\par
295 \par
296     {\cf20 /* is a high value that will be used to compare and determine the shortest event time */}\par
297     {\cf18 float} min_time_next_event = 1.0e+29;\par
298 \par
299     {\cf20 /* initializes to zero because there is no event selected */}\par
300     state->next_event_type = 0;\par
301     \par
303 \par
304     {\cf19 for} ({\cf18 int} i = 1; i <= state->num_events; ++i) {\cf20 /* event [1] is included in the comparison because it may be the next event */}\par
305         {\cf19 if} (events->time_next_event[i] < min_time_next_event) \{\par
306             min_time_next_event = events->time_next_event[i];\par
307             state->next_event_type = i; {\cf20 /* the index value of the event with the shortest time is updated */}\par
308         \}\par
309 \par
310 \par
311     {\cf19 if} (state->next_event_type == 0) \{ {\cf20 /* if no event was selected it means that the event list is empty so the simulation is stopped */}\par
312         {\cf20 /* The event list is empty, so stop the simulation. */}\par
313         fprintf(files->outfile, {\cf22 "\\nEvent list empty at time %f"}, events->sim_time);\par
314         exit(1);\par
315     \}\par
316 \par
317     {\cf20 /* The event list is not empty so we advance the simulation clock */}\par
318     events->sim_time = min_time_next_event; \par
319 \par
320 \}\par
}
}
{\xe \v update_time_avg_stats\:fila1s.c}
{\xe \v fila1s.c\:update_time_avg_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update_time_avg_stats ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update area accumulators for time-average statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function update_time_avg_stats: updates the time-based statistics for the simulation, such as the area under the number-in-queue and server utilization curves. Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute time since last event, and update last-event-time marker.\par
Update area under number-in-queue function.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 262                                                                                         \{\par
263     \par
264     \par
265     {\cf18 float} time_since_last_event; \par
266 \par
267     {\cf20 /* This calculation determines the time that has passed since the last processed event.}\par
268 {\cf20        It is essential to calculate the areas under the curves of the state variables */}\par
269     time_since_last_event = events->sim_time - events->time_last_event;\par
270     events->time_last_event  = events->sim_time; \par
271     \par
272     {\cf20 /* This metric is useful to calculate the average number of customers in the queue during the simulation */}\par
273     stats->area_num_in_q  += state->num_in_q * time_since_last_event; \par
274 \par
275     {\cf20 /* Update the area under the server-status function for each server */}\par
276     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; ++i)\par
277         stats->area_server_status[i] += state->server_status[i] * time_since_last_event;\par
278     \par
279 \par
280 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lab1/fila1s.h File Reference\par \pard\plain 
{\tc\tcl2 \v lab1/fila1s.h}
{\xe \v lab1/fila1s.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for simulation and modelling. }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <math.h>}\par
{\f2 #include "lcgrand.h"}\par
{\f2 #include <time.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Data Structures\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SystemState}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that represents the system state. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Statistics}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that holds statistics for time-average calculations. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EventList}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure that keeps track of event timing functions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Files}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Structure with file pointers for input and output op. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b Q_LIMIT}\~ 100\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MAX_SERVERS}\~ 99 /* As we have no repetitions, then n+1< 100, that is, n<99 */\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b BUSY}\~ 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b IDLE}\~ 0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ask_streams} ({\b SystemState} *state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b generate_other_streams} ({\b SystemState} *state)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b selectFreeServer} ({\b SystemState} *state, {\b Statistics} *stats)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initialize} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events, int stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b timing} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b arrive} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b depart} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b report} ({\b SystemState} *state, {\b Statistics} *stats, {\b Files} *files, {\b EventList} *events)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update_time_avg_stats} ({\b SystemState} *state, {\b Statistics} *stats, {\b EventList} *events)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update area accumulators for time-average statistics. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b expon} (float mean, int stream)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for simulation and modelling. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
It uses the code from Simulation and Modelling 5e by Averill M. Law B. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v BUSY\:fila1s.h}
{\xe \v fila1s.h\:BUSY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define BUSY\~ 1}}
\par
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Mnemonics for server's being busy \par
}}
{\xe \v IDLE\:fila1s.h}
{\xe \v fila1s.h\:IDLE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define IDLE\~ 0}}
\par
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
and idle. \par
}}
{\xe \v MAX_SERVERS\:fila1s.h}
{\xe \v fila1s.h\:MAX_SERVERS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MAX_SERVERS\~ 99 /* As we have no repetitions, then n+1< 100, that is, n<99 */}}
\par
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Q_LIMIT\:fila1s.h}
{\xe \v fila1s.h\:Q_LIMIT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define Q_LIMIT\~ 100}}
\par
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Stream (1.100) to be defined by input and different for each variable\par
External definitions for single-server queueing system.\par
Header file for random-number generator.\par
Limit on queue length. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v arrive\:fila1s.h}
{\xe \v fila1s.h\:arrive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void arrive ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Arrival event function.\par
Function arrive : handles customers arriving at the queue by scheduling the next arrival, checking server availability, and managing the queue if all servers are occupied.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to track queue size, server status, and number of lost customers.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, updated to increment lost customers if the queue is full.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure, used for handling queue overflow conditions.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to schedule the next arrival event. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
We increased the number of users in the waiting list\par
Check to see whether an overflow condition exists.\par
The queue has overflowed, so stop the simulation.\par
There is still room in the queue, so store the time of arrival of the arriving customer at the (new) end of time_arrival.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 334                                                                                         \{\par
335     \par
336     {\cf18 float} delay;\par
337     \par
338     {\cf20 /* Schedule the next arrival event */}\par
339     events->time_next_event[1] = events->sim_time + expon(state->mean_interarrival,state->streams[0]); \par
340 \par
341     {\cf20 /* Checks if there are free servers, if there are not, the function returns -1 */}\par
342     {\cf18 int} free_server_index = selectFreeServer(state, stats);\par
343 \par
344     {\cf19 if} (free_server_index != -1) \{ {\cf20 /* There are free servers */}\par
345         delay = 0.0; {\cf20 /* The customer is served immediately, so the delay = 0 */}\par
346 \par
347         {\cf20 /* Increases the number of customers served */}\par
348         ++state->num_custs_delayed;\par
349 \par
350         {\cf20 /* Mark the server as busy */}\par
351         state->server_status[free_server_index] = BUSY;\par
352 \par
353         {\cf20 /* Schedule a departure for this customer (service completion) */}\par
354         events->time_next_event[free_server_index] = events->sim_time + expon(state->mean_service, state->streams[free_server_index-1]);\par
355     \}\par
356 \par
357     {\cf19 else}\{ {\cf20 /* Todos os servers estao ocupados */}\par
358 \par
359         {\cf19 if}(state->without_infinite_queue == 0)\{ {\cf20 /* If we don't have a queue -> M/M/n/0 (Erlang-B): Reject customer */}\par
360             stats->lost_customers++;\par
361         \}\par
362 \par
363         {\cf19 else}\{\par
364 \par
365             ++state->num_in_q; \par
366             \par
367 \par
368             {\cf19 if} (state->num_in_q > Q_LIMIT) \{\par
369 \par
370                 fprintf(files->outfile, {\cf22 "\\nOverflow of the array time_arrival at"});\par
371                 fprintf(files->outfile, {\cf22 " time %f"}, events->sim_time);\par
372                 exit(2);\par
373             \}\par
375 \par
376             state->time_arrival[state->num_in_q] = events->sim_time;\par
377 \par
378         \}\par
379     \}\par
380 \}\par
}
}
{\xe \v ask_streams\:fila1s.h}
{\xe \v fila1s.h\:ask_streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ask_streams ({\b SystemState} * state)}}
\par
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Code from Simulation and Modelling 5e Averill M. Law B Function ask_streams: prompts the user to enter two seeds, one for arrivals and another for departures. Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->streams[i]: array updated with the first two seeds.\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: pointer to the system state structure where seeds are stored. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 19                                     \{\par
20 \par
21 \par
22     {\cf20 /* We ask for 2 seeds, the first is reserved for arrivals and the second is used for departures */}\par
23     {\cf19 for}({\cf18 int} i = 0; i < 2; i++) \{\par
24             {\cf19 do} \{\par
25                 {\cf19 if}(i==0)\{\par
26                     printf({\cf22 "Escreve a semente correspondente as chegadas: "});\par
27                 \}\par
28                 {\cf19 else}\{\par
29                     printf({\cf22 "Escreve a semente correspondente as partidas: "});\par
30                 \}\par
31                 \par
32                 {\cf19 if} (scanf({\cf22 "%d"}, &state->streams[i]) != 1) \{  \par
33                     printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
34                     {\cf18 int} ch;\par
35                     {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF); \par
36                     state->streams[i] = -1;\par
37                 \}\par
38 \par
39                 {\cf19 if}(state->streams[i] <= 0 || state->streams[i] > 100) \{ {\cf20 /* We guarantee that each seed introduced is within the desired values  */}\par
40                     printf({\cf22 "As sementes t\'EAm de estar compreendidas entre [1, 100]. \\n"});\par
41                 \}\par
42             \} {\cf19 while}(state->streams[i] <= 0 || state->streams[i] > 100 || (i == 1 && state->streams[0] == state->streams[1])); {\cf20 /* This loop ensures that the two seeds are different from each other */}\par
43         \}\par
44 \par
45 \}\par
}
}
{\xe \v depart\:fila1s.h}
{\xe \v fila1s.h\:depart}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void depart ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Departure event function.\par
Function depart : handles customer departures by updating queue length, calculating delay for the customer beginning service, and setting the server status to idle if the queue is empty.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to track server status, queue length, and customer arrival times.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, updated to accumulate total delay and number of customers delayed.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to schedule the next departure or set it to infinity if the server becomes idle. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the queue is empty\par
The queue is empty so make the server idle and eliminate the departure (service completion) event from consideration.\par
Compute the delay of the customer who is beginning service and update the total delay accumulator.\par
Increment the number of customers delayed, and schedule departure.\par
Move each customer in queue (if any) up one place. With a circular queue it is much better\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 393                                                                       \{\par
394     \par
395     {\cf18 float} delay;\par
396 \par
397 \par
398     {\cf19 if} (state->num_in_q == 0) \{\par
400 \par
401         state->server_status[state->next_event_type] = IDLE; {\cf20 /* The next_event type corresponds to the server index -> see in the timing function */}\par
402         events->time_next_event[state->next_event_type] = 1.0e+30; {\cf20 /* Sets the next event to infinite */}\par
403     \}\par
404     {\cf19 else} \{ {\cf20 /* The queue is not empty */}\par
405         \par
406         {\cf20 /* So the number of customers in the queue decreases */}\par
407         --state->num_in_q;\par
408 \par
409 \par
410         delay = events->sim_time - state->time_arrival[1];\par
411 \par
412         stats->total_of_delays += delay;\par
413 \par
414 \par
415         ++state->num_custs_delayed;\par
416         events->time_next_event[2] = events->sim_time + expon(state->mean_service,state->streams[state->next_event_type]);\par
417 \par
418 \par
419         {\cf19 for} ({\cf18 int} i = 1; i <= state->num_in_q; ++i)\par
420             state->time_arrival[i] = state->time_arrival[i + 1];\par
421     \}\par
422 \par
423 \}\par
}
}
{\xe \v expon\:fila1s.h}
{\xe \v fila1s.h\:expon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float expon (float mean, int stream)}}
\par
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exponential variate generation function. {\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i mean} \cell }{is the expected value of the random variable \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{identifies the stream for the uniform distribution \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
an exponential random variate with mean "mean".\par
}}Function expon: calculates an exponentially distributed random variable.\par
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
mean: mean of the exponential distribution\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: seed for random number generation.\par}
Returns: an exponentially distributed value with the specified mean. \par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 140                                     \{\par
141     {\cf19 return} -mean * logf(lcgrand(stream));\par
142 \}\par
}
}
{\xe \v generate_other_streams\:fila1s.h}
{\xe \v fila1s.h\:generate_other_streams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void generate_other_streams ({\b SystemState} * state)}}
\par
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function generate_other_streams: generates additional seed streams for servers.\par
Input/output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->streams: array updated with generated seeds\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: structure containing the number of servers. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 58                                                \{\par
59 \par
60     {\cf20 /* This function generates the remaining seeds used. If there are n servers then we need to generate n-1 seeds because the first seed corresponding to arrival is used for the first server. */}\par
61 \par
62     {\cf20 /* This loop serves to ensure that the seeds now generated are not the same as the seed used by the arrival.}\par
63 {\cf20     Furthermore, it guarantees that seed generation is circular, that is, if we reach index 1001 it becomes 1. }\par
64 {\cf20     Seeds are generated from the starting seed for server 1 and the rest are obtained by adding 1 unit. */}\par
65 \par
66     {\cf19 for}({\cf18 int} i= 2; i<=state->number_of_servers + 1; i++)\{\par
67         state->streams[i] = state->streams[i-1] + 1; \par
68         {\cf19 if}(state->streams[i] == state->streams[0])\{\par
69             state->streams[i] = state->streams[i-1] + 2;\par
70         \}\par
71         {\cf19 if} (state->streams[i] == 101) \{\par
72             state->streams[i] = 1;\par
73         \}   \par
74     \}\par
75 \par
76     printf({\cf22 "Streams = [ "});\par
77 \par
78     {\cf20 /* This loop is only used to show the array with all the seeds that will be used */}\par
79     {\cf19 for}({\cf18 int} i=0; i<=state->number_of_servers + 1 ; i++)\{\par
80         {\cf19 if}(i < state->number_of_servers+1)\{\par
81             printf({\cf22 " %d, "}, state->streams[i]);\par
82         \}\par
83         {\cf19 else}\{\par
84             printf({\cf22 " %d ] \\n"}, state->streams[i]);\par
85         \}\par
86     \}\par
87 \par
88 \}\par
}
}
{\xe \v initialize\:fila1s.h}
{\xe \v fila1s.h\:initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void initialize ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events, int stream)}}
\par
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Initialization function.\par}
Function initialize: initializes the state of the simulation system, including setting up the simulation clock, random number generators, state variables, and event list\par
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: Random number stream used for generating arrival times.\par}
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stream: Random number stream used for generating arrival times. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initialize the simulation clock.\par
These are the departures for each server. We put a big number.\par
Update the number of events\par
Number of custumers in queu start in zero\par
Initialize the statistical counters.\par
Initialize event list. Since no customers are present, the departure (service completion) event is eliminated from consideration.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 160                                                                                          \{\par
161     \par
162     events->sim_time = 0.0; \par
163 \par
164 \par
165     events->time_next_event[1] = events->sim_time + expon(state->mean_interarrival, stream); {\cf20 /* time_next_event[1] representa o evento de chegada*/}\par
166     {\cf20 // events->time_next_event[2] = 1.0e+30;}\par
167 \par
168     {\cf20 /* Initialize all servers as IDLE */}\par
169     {\cf20 /* Initialize departure events for each server */}\par
170     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; ++i) \{\par
171         state->server_status[i] = IDLE;\par
172         stats->area_server_status[i] = 0.0;\par
173         {\cf20 /* We use i+2 here because we start at [2] since position [1] is for the arrival event */}\par
174         events->time_next_event[i] = 1.0e+30; \par
175     \}\par
176 \par
177 \par
178     state->num_events=state->number_of_servers+1 ; \par
179 \par
180     state->num_in_q = 0; \par
181     events->time_last_event = 0.0; {\cf20 /* Time of last event starts in zero */}\par
182 \par
183     state->num_custs_delayed =   0; {\cf20 /* Number of custumers */}\par
184     stats->total_of_delays   =   0.0; {\cf20 /* Number of delays */}\par
185     stats->area_num_in_q     =   0.0; {\cf20 /* Number of the utilization rate */}\par
186     stats->lost_customers    =   0; {\cf20 /* Number of lost costumers */}\par
188 \par
189     \par
190 \}\par
}
}
{\xe \v report\:fila1s.h}
{\xe \v fila1s.h\:report}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void report ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Report generator function. Compute and write estimates of desired measures of performance.\par
Function report: writes the simulation results to the output file, including performance metrics like average delay, lost customers, and server utilization.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure.\par}
Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
Writes the formatted simulation report to the output file. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Write report heading and input parameters to the output file.\par
Print the average delay in queue per client\par
Print the average number of lost clients\par
Print the average number of clients in queue\par
Print the average server utilization. We use this loop to ensure that if area_server_status == 0 then we avoid divisions by zero\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 207                                                                                         \{\par
208 \par
209 \par
210     fprintf(files->outfile, {\cf22 "Single-server queueing system\\n\\n"});\par
211     fprintf(files->outfile, {\cf22 "Mean interarrival time%11.3f minutes\\n\\n"}, state->mean_interarrival);\par
212     fprintf(files->outfile, {\cf22 "Mean service time%16.3f minutes\\n\\n"}, state->mean_service);\par
213     fprintf(files->outfile, {\cf22 "Number of customers%14d\\n\\n"}, state->num_delays_required);\par
214     {\cf19 if}(state->without_infinite_queue == 0 )\{\par
215         fprintf(files->outfile, {\cf22 "Without Queue\\n\\n"});\par
216     \}\par
217     {\cf19 else}\{\par
218         fprintf(files->outfile, {\cf22 "With Queue\\n\\n"});\par
219     \}\par
220     \par
221 \par
222 \par
223     fprintf(files->outfile, {\cf22 "\\n\\nAverage delay in queue per client %11.3f minutes\\n\\n"}, stats->total_of_delays / state->num_custs_delayed);\par
224 \par
225     {\cf19 if}(state->without_infinite_queue == 0)\{  {\cf20 /* If we don't have an infinite queue */}\par
226 \par
227         fprintf(files->outfile, {\cf22 "Average number of lost clients %14.3f\\n\\n"}, stats->lost_customers);\par
228     \}\par
229 \par
230     {\cf19 else}\{ {\cf20 /* If we have an infinite queue */}\par
231 \par
232         fprintf(files->outfile, {\cf22 "Average number of clients in queue %10.3f\\n\\n"}, stats->area_num_in_q / events->sim_time);\par
233     \}\par
234     \par
235 \par
237 \par
238     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; i++ )\{\par
239         {\cf19 if} (events->sim_time > 0) \{\par
240             fprintf(files->outfile, {\cf22 "Server %d utilization%25.3f\\n\\n"}, i-1 ,stats->area_server_status[i] / events->sim_time);\par
241          \} \par
242          \par
243         {\cf19 else} \{ {\cf20 /* To avoid division by zero if events->sim_time > 0 */}\par
244             fprintf(files->outfile, {\cf22 "Server %d utilization%25.3f \\n\\n"}, i-1, 0.0);\par
245         \}\par
246     \}\par
247 \par
248 \par
249     fprintf(files->outfile, {\cf22 "Time simulation ended%26.3f minutes"}, events->sim_time);\par
250 \}\par
}
}
{\xe \v selectFreeServer\:fila1s.h}
{\xe \v fila1s.h\:selectFreeServer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int selectFreeServer ({\b SystemState} * state, {\b Statistics} * stats)}}
\par
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Function selectFreeServer: selects an available server based on the area of each server.\par
Output parameters: index of the available server or -1 if all are busy.\par
Input/output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats->area_server_status: indicates the area of each server.\par}
Input parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state->server_status: array with the status (IDLE/BUSY) of each server. \par}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 103                                                               \{ \par
104     \par
105     {\cf18 int} livre = -1; {\cf20 /* At the beginning we assume that no server is IDLE */}\par
106     {\cf18 int} aux = stats->area_server_status[2]; {\cf20 /* Let's assume that the first server is the one with the lowest utilization rate */} \par
107     {\cf18 int} indice = 2; {\cf20 /* We assume that the first server (index = 2) is the one with the lowest utilization rate */}\par
108 \par
109     {\cf20 /* This loop serves to understand which server has the lowest usage rate and is at the same time free */}\par
110     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers+1; ++i) \{\par
111         {\cf19 if} (state->server_status[i] == IDLE) \{\par
112             livre = 1; {\cf20 /* There is at least one free server */}\par
113             {\cf19 if}(stats->area_server_status[i]<=aux)\{\par
114                 aux = stats->area_server_status[i];\par
115                 indice = i; \par
116             \}\par
117             \par
118         \}\par
119     \}\par
120     {\cf19 if} (livre == -1)\{\par
121         {\cf19 return} -1; {\cf20 /* returns -1 if all servers are busy */}\par
122     \}\par
123     {\cf19 else}\{\par
124         {\cf19 return} indice; {\cf20 /* returns the index of the first available server */}\par
125     \}\par
126     \par
127 \}\par
}
}
{\xe \v timing\:fila1s.h}
{\xe \v fila1s.h\:timing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void timing ({\b SystemState} * state, {\b Statistics} * stats, {\b Files} * files, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Timing function.\par
Function timing : determines the next event based on the times stored in the event list. Advances the simulation clock to the time of the next event. Checks if the event list is empty; if so, the simulation terminates.\par
Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure, updated to set the next event type.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure, used here only for access to simulation variables.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
files: Pointer to the file management structure, used for writing termination messages if the event list is empty.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure, updated to set the simulation time to the time of the next event. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function loops through all event types and checks the time of each stored event. The event with the shortest time is the next to happen\par
Check to see whether the event list is empty.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 294                                                                                         \{\par
295 \par
296     {\cf20 /* is a high value that will be used to compare and determine the shortest event time */}\par
297     {\cf18 float} min_time_next_event = 1.0e+29;\par
298 \par
299     {\cf20 /* initializes to zero because there is no event selected */}\par
300     state->next_event_type = 0;\par
301     \par
303 \par
304     {\cf19 for} ({\cf18 int} i = 1; i <= state->num_events; ++i) {\cf20 /* event [1] is included in the comparison because it may be the next event */}\par
305         {\cf19 if} (events->time_next_event[i] < min_time_next_event) \{\par
306             min_time_next_event = events->time_next_event[i];\par
307             state->next_event_type = i; {\cf20 /* the index value of the event with the shortest time is updated */}\par
308         \}\par
309 \par
310 \par
311     {\cf19 if} (state->next_event_type == 0) \{ {\cf20 /* if no event was selected it means that the event list is empty so the simulation is stopped */}\par
312         {\cf20 /* The event list is empty, so stop the simulation. */}\par
313         fprintf(files->outfile, {\cf22 "\\nEvent list empty at time %f"}, events->sim_time);\par
314         exit(1);\par
315     \}\par
316 \par
317     {\cf20 /* The event list is not empty so we advance the simulation clock */}\par
318     events->sim_time = min_time_next_event; \par
319 \par
320 \}\par
}
}
{\xe \v update_time_avg_stats\:fila1s.h}
{\xe \v fila1s.h\:update_time_avg_stats}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void update_time_avg_stats ({\b SystemState} * state, {\b Statistics} * stats, {\b EventList} * events)}}
\par
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Update area accumulators for time-average statistics. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function updates statistical accumulators for calculating time-averaged values, such as the average number of items in the queue and the server's busy time. It computes the time since the last event, updates the {\f2 time_last_event}  marker, and then increments the appropriate accumulators based on the current state of the system.\par
Function update_time_avg_stats: updates the time-based statistics for the simulation, such as the area under the number-in-queue and server utilization curves. Input/Output parameters:{
\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
state: Pointer to the system state structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
stats: Pointer to the statistics structure.\par
\pard\plain {\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\nowidctlpar\cf0\hich\af0\langfe2052\dbch\af0\afs24\lang1081\loch\f0\fs24\lang1033{\listtext\pard\plain \hich\af3\dbch\af3\loch\f8 \'01\u9702\tab}\ilvl1\ls1 \li0\ri0\lin0\rin0\fi-360\tx720\li720\ri0\lin720\rin0\fi-360\kerning1\hich\af4\dbch\af5\rtlch \ltrch\loch\fs20
events: Pointer to the event list structure. \par}
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Compute time since last event, and update last-event-time marker.\par
Update area under number-in-queue function.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 262                                                                                         \{\par
263     \par
264     \par
265     {\cf18 float} time_since_last_event; \par
266 \par
267     {\cf20 /* This calculation determines the time that has passed since the last processed event.}\par
268 {\cf20        It is essential to calculate the areas under the curves of the state variables */}\par
269     time_since_last_event = events->sim_time - events->time_last_event;\par
270     events->time_last_event  = events->sim_time; \par
271     \par
272     {\cf20 /* This metric is useful to calculate the average number of customers in the queue during the simulation */}\par
273     stats->area_num_in_q  += state->num_in_q * time_since_last_event; \par
274 \par
275     {\cf20 /* Update the area under the server-status function for each server */}\par
276     {\cf19 for} ({\cf18 int} i = 2; i <= state->number_of_servers + 1; ++i)\par
277         stats->area_server_status[i] += state->server_status[i] * time_since_last_event;\par
278     \par
279 \par
280 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
fila1s.h\par \pard\plain 
{\tc\tcl2 \v lab1/fila1s.h}
{\xe \v lab1/fila1s.h}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef FILA1S_H}\par
2 {\cf21 #define FILA1S_H}\par
3 \par
12 {\cf21 #include <stdio.h>}\par
13 {\cf21 #include <stdlib.h>}\par
14 {\cf21 #include <math.h>}\par
15 {\cf21 #include "lcgrand.h"}\par
16 {\cf21 #include <time.h>}\par
17 {\cf21 #include <string.h>}\par
18 \par
21 {\cf21 #define Q_LIMIT 100}\par
22 \par
23 {\cf20 /* limit of the number of servers*/}\par
24 {\cf21 #define MAX_SERVERS 99 }{\cf20 /* As we have no repetitions, then n+1< 100, that is, n<99 */}{\cf21 }\par
25 \par
27 {\cf21 #define BUSY 1}\par
28 \par
30 {\cf21 #define IDLE 0}\par
31 \par
35 {\cf17 typedef} {\cf17 struct }\{\par
36     {\cf18 int} next_event_type;            \par
37     {\cf18 int} num_custs_delayed;          \par
38     {\cf18 int} num_delays_required;        \par
39     {\cf18 int} num_in_q;                   \par
40     {\cf18 int} server_status[MAX_SERVERS + 2];              \par
41     {\cf18 float} time_arrival[Q_LIMIT + 1];    \par
42     {\cf18 float} mean_interarrival;        \par
43     {\cf18 float} mean_service;             \par
44     {\cf18 int} number_of_servers; \par
45     {\cf18 int} num_events; \par
46     {\cf18 int} streams[MAX_SERVERS + 1];\par
47     {\cf18 int} without_infinite_queue; {\cf20 /* Infinite queue = 1 , without queue = 0 */}\par
48     {\cf18 float} A; {\cf20 /* !< Tr\'E1fego oferecido */}\par
49 \} SystemState;\par
50 \par
54 {\cf17 typedef} {\cf17 struct }\{\par
55     {\cf18 float} area_num_in_q;        \par
56     {\cf18 float} area_server_status[MAX_SERVERS + 2];   \par
57     {\cf18 float} total_of_delays;      \par
58     {\cf18 int} lost_customers; \par
59 \} Statistics;\par
60 \par
64 {\cf17 typedef} {\cf17 struct }\{\par
65     {\cf18 float} sim_time;             \par
66     {\cf18 float} time_last_event;      \par
67     {\cf18 float} time_next_event[MAX_SERVERS + 2];   \par
68 \} EventList;\par
69 \par
73 {\cf17 typedef} {\cf17 struct }\{\par
74     FILE * infile;   \par
75     FILE * outfile;  \par
76 \} Files;\par
77 \par
78 {\cf18 void} ask_streams(SystemState *state);\par
79 \par
80 {\cf18 void} generate_other_streams(SystemState *state);\par
81 \par
82 {\cf18 int} selectFreeServer(SystemState * state, Statistics * stats);\par
83 \par
85 {\cf18 void} initialize(SystemState *state, Statistics *stats, EventList *events, {\cf18 int} stream);\par
86 \par
88 {\cf18 void} timing(SystemState *state, Statistics *stats, Files* files, EventList *events);\par
89 \par
91 {\cf18 void} arrive(SystemState *state, Statistics *stats, Files* files, EventList *events);\par
92 \par
94 {\cf18 void} depart(SystemState *state, Statistics *stats, EventList *events);\par
95 \par
97 {\cf18 void} report(SystemState* state, Statistics* stats, Files* files, EventList* events);\par
98 \par
107 {\cf18 void} update_time_avg_stats(SystemState *state, Statistics *stats, EventList *events);\par
108 \par
114 {\cf18 float} expon({\cf18 float} mean, {\cf18 int} stream);\par
115 \par
116 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lab1/lcgrand.c File Reference\par \pard\plain 
{\tc\tcl2 \v lab1/lcgrand.c}
{\xe \v lab1/lcgrand.c}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lcgrand.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lcgrand} (int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate the next U(0, 1) random number. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lcgrandst} (long zset, int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the seed for the random number stream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b lcgrandgt} (int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current seed for the random number stream. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v lcgrand\:lcgrand.c}
{\xe \v lcgrand.c\:lcgrand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float lcgrand (int stream)}}
\par
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate the next U(0, 1) random number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To obtain the next U(0,1) random number from stream "stream" execute u = lcgrand(stream);\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{index for the random stream to be used \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
U(0,1) random number from stream "stream" \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 51                           \{\par
52     {\cf18 long} zi, lowprd, hi31;\par
53     \par
54     zi = zrng[stream];\par
55     lowprd = (zi & 65535) * MULT1;\par
56     hi31 =(zi >> 16) * MULT1 + (lowprd >> 16);\par
57     zi = ((lowprd & 65535) - MODLUS) + ((hi31 & 32767) << 16) + (hi31 >> 15);\par
58     {\cf19 if} (zi < 0) zi += MODLUS;\par
59     lowprd = (zi & 65535) * MULT2;\par
60     hi31 = (zi >> 16) * MULT2 + (lowprd >> 16);\par
61     zi = ((lowprd & 65535) - MODLUS) +((hi31 & 32767) << 16) + (hi31 >> 15);\par
62     {\cf19 if} (zi < 0) zi += MODLUS;\par
63     zrng[stream] = zi;\par
64     {\cf19 return} (zi >> 7 | 1) / 16777216.0;\par
65 \}\par
}
}
{\xe \v lcgrandgt\:lcgrand.c}
{\xe \v lcgrand.c\:lcgrandgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long lcgrandgt (int stream)}}
\par
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current seed for the random number stream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns the current seed value for the random number generator stream specified by {\f2 stream} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{Index of the random number stream. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current seed (zrng) for the specified stream. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                             \{\par
72     {\cf19 return} zrng[stream];\par
73 \}\par
}
}
{\xe \v lcgrandst\:lcgrand.c}
{\xe \v lcgrand.c\:lcgrandst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lcgrandst (long zset, int stream)}}
\par
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the seed for the random number stream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zset} \cell }{The new seed value to set for the stream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{Index of the random number stream to set the seed for. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                        \{\par
68     zrng[stream] = zset;\par
69 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lab1/lcgrand.h File Reference\par \pard\plain 
{\tc\tcl2 \v lab1/lcgrand.h}
{\xe \v lab1/lcgrand.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for the random number generator functions. }}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MODLUS}\~ 2147483647\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULT1}\~ 24112\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b MULT2}\~ 26143\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b lcgrand} (int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate the next U(0, 1) random number. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b lcgrandst} (long zset, int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the seed for the random number stream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
long {\b lcgrandgt} (int stream)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current seed for the random number stream. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Header file for the random number generator functions. \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This file defines constants and declares functions for generating uniformly distributed random numbers. It includes the main function lcgrand and the associated function lcgrandst and lcgrandft for seed management. This file (named {\b lcgrand.h}) should be included in any program using these functions by executing #include "lcgrand.h" \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v MODLUS\:lcgrand.h}
{\xe \v lcgrand.h\:MODLUS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MODLUS\~ 2147483647}}
\par
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Define the constants. Modulus value for the LCG algorithm. \par
}}
{\xe \v MULT1\:lcgrand.h}
{\xe \v lcgrand.h\:MULT1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULT1\~ 24112}}
\par
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplier value for the LCG algorithm. \par
}}
{\xe \v MULT2\:lcgrand.h}
{\xe \v lcgrand.h\:MULT2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define MULT2\~ 26143}}
\par
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Multiplier 2 for the LCG algorithm. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v lcgrand\:lcgrand.h}
{\xe \v lcgrand.h\:lcgrand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float lcgrand (int stream)}}
\par
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Generate the next U(0, 1) random number. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
To obtain the next U(0,1) random number from stream "stream" execute u = lcgrand(stream);\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{index for the random stream to be used \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
U(0,1) random number from stream "stream" \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 51                           \{\par
52     {\cf18 long} zi, lowprd, hi31;\par
53     \par
54     zi = zrng[stream];\par
55     lowprd = (zi & 65535) * MULT1;\par
56     hi31 =(zi >> 16) * MULT1 + (lowprd >> 16);\par
57     zi = ((lowprd & 65535) - MODLUS) + ((hi31 & 32767) << 16) + (hi31 >> 15);\par
58     {\cf19 if} (zi < 0) zi += MODLUS;\par
59     lowprd = (zi & 65535) * MULT2;\par
60     hi31 = (zi >> 16) * MULT2 + (lowprd >> 16);\par
61     zi = ((lowprd & 65535) - MODLUS) +((hi31 & 32767) << 16) + (hi31 >> 15);\par
62     {\cf19 if} (zi < 0) zi += MODLUS;\par
63     zrng[stream] = zi;\par
64     {\cf19 return} (zi >> 7 | 1) / 16777216.0;\par
65 \}\par
}
}
{\xe \v lcgrandgt\:lcgrand.h}
{\xe \v lcgrand.h\:lcgrandgt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
long lcgrandgt (int stream)}}
\par
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Get the current seed for the random number stream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns the current seed value for the random number generator stream specified by {\f2 stream} .\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{Index of the random number stream. \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
The current seed (zrng) for the specified stream. \par
}}}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 71                             \{\par
72     {\cf19 return} zrng[stream];\par
73 \}\par
}
}
{\xe \v lcgrandst\:lcgrand.h}
{\xe \v lcgrand.h\:lcgrandst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void lcgrandst (long zset, int stream)}}
\par
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the seed for the random number stream. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i zset} \cell }{The new seed value to set for the stream. \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i stream} \cell }{Index of the random number stream to set the seed for. \cell }
{\row }
}
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 67                                        \{\par
68     zrng[stream] = zset;\par
69 \}\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lcgrand.h\par \pard\plain 
{\tc\tcl2 \v lab1/lcgrand.h}
{\xe \v lab1/lcgrand.h}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef LCGRAND_H}\par
2 {\cf21 #define LCGRAND_H}\par
3 \par
16 {\cf21 #define MODLUS 2147483647  }\par
17 {\cf21 #define MULT1 24112        }\par
18 {\cf21 #define MULT2 26143        }\par
29 {\cf18 float} lcgrand({\cf18 int} stream);\par
30 \par
31 {\cf20 // as seguintes n\'E3o vamos utilizar}\par
32 {\cf20 // s\'F3 vamos utilizar a de cima - lcgrand - que retorna um valor aleat\'F3rio entre 0 e 1 uniformemente distribu\'EDdo}\par
33 {\cf20 // devolve 1 ou +, mas a sua m\'E9dia dar\'E1 0.5}\par
34 \par
41 {\cf18 void} lcgrandst({\cf18 long} zset, {\cf18 int} stream);\par
42 \par
52 {\cf18 long} lcgrandgt({\cf18 int} stream);\par
53 \par
54 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lab1/simula_fila1s.c File Reference\par \pard\plain 
{\tc\tcl2 \v lab1/simula_fila1s.c}
{\xe \v lab1/simula_fila1s.c}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "lcgrand.h"}\par
{\f2 #include "fila1s.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:simula_fila1s.c}
{\xe \v simula_fila1s.c\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int argc, char * argv[])}}
\par
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Main function that runs the simulation of the M/M/1 queueing system.\par
The main function reads input parameters, initializes the simulation, processes events, and outputs results.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs16\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Exit status of the program, EXIT_SUCCESS or EXIT_FAILURE. \par
}}}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
< Structure to hold the system state variables.\par
< Structure to hold the statistical variables.\par
< Structure to hold the event list variables.\par
< Structure to hold the file pointers.\par
Set the initial return value to EXIT_FAILURE in case something goes wrong.\par
Check if the input file is provided as an argument.\par
Open input file and read the parameters.\par
Read input parameters.\par
Verifies the validity of the parameters\par
Ask for parameters all parameters and guarantees the validity of those\par
Open input file and write the parameters and the random seeds.\par
Asks for the output file. Open the output file\par
Initialize the simulation.\par
Run the simulation while the required number of customers has not been delayed.\par
Determine the next event (either an arrival or departure).\par
Update the time-average statistics based on the time elapsed since the last event.\par
Process the next event based on its type (1 for arrival, 2 for departure).\par
Invoke the report generator and end the simulation.\par
}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 31                                  \{\par
32 \par
33     SystemState state;  \par
34     Statistics stats;       \par
35     EventList events;       \par
36     Files files;                \par
37 \par
38 \par
39     {\cf18 int} is_ok = EXIT_FAILURE;\par
40 \par
41 \par
42     {\cf18 int} something_wrong = 0; {\cf20 /* Auxiliary variable to know if something went wrong when reading the parameters */}\par
43 \par
44 \par
45     \par
46     {\cf19 if} (argc >= 2) \{ {\cf20 /* If in the input argument we have the name of the file we want to read */}\par
47         \par
48 \par
49         {\cf19 if}(argc == 2) \{\par
50             printf({\cf22 "Usage: %s <%s>\\n"}, argv[0], argv[1]);\par
51             files.infile = fopen(argv[1], {\cf22 "ra"});\par
52 \par
53             {\cf19 if}(!files.infile) \{\par
54                 printf({\cf22 "File opening of  %s"}, argv[1]);\par
55                 perror({\cf22 " failed"});\par
56                 {\cf19 return} is_ok;\par
57             \}\par
58 \par
59 \par
60             fscanf(files.infile, {\cf22 "%f %f %d %d %d %d %d"}, &state.mean_interarrival, &state.mean_service, &state.num_delays_required, &state.number_of_servers, &state.without_infinite_queue, &state.streams[0], &state.streams[1]);\par
61             \par
62  \par
63             {\cf19 if} (state.streams[0] <= 0 || state.streams[1] <= 0 || state.streams[0] >= 100 || state.streams[1] >= 100) \{\par
64                 fprintf(stderr, {\cf22 "Dados de leitura incorretos -> Caracteres invalidos ou numeros negativos\\n"});\par
65                 something_wrong = 1; \par
66             \}\par
67 \par
68             {\cf19 if}(state.streams[0] == state.streams[1])\{\par
69                 fprintf(stderr, {\cf22 "As sementes nao podem ser iguais\\n"});\par
70                 something_wrong = 1;\par
71             \}\par
72 \par
73             {\cf19 if} (state.mean_interarrival <= 0 || state.mean_service <= 0 || state.num_delays_required <= 0 || state.number_of_servers <= 0 ) \{\par
74                 fprintf(stderr, {\cf22 "Dados de leitura incorretos -> Caracteres invalidos ou numeros negativos\\n"});\par
75                 something_wrong = 1;\par
76             \}\par
77 \par
78             {\cf19 if}(state.number_of_servers> MAX_SERVERS)\{\par
79                 fprintf(stderr, {\cf22 "O numero de server nao respeita as condicoes necessarias\\n"});\par
80                 something_wrong = 1;\par
81             \}\par
82 \par
83             {\cf19 if} (state.without_infinite_queue != 0 && state.without_infinite_queue != 1 ) \{\par
84                 fprintf(stderr, {\cf22 "Dados incorretos:    With Queue = 1      Without Queue = 0 \\n"});\par
85                 something_wrong = 1;\par
86             \}\par
87 \par
88             {\cf20 /* We calculate the offered rate */}\par
89             state.A = 1/state.mean_interarrival * state.mean_service; \par
90             \par
91             {\cf20 /* We confirm whether the traffic offered is greater than or equal to the number of servers */}\par
92             {\cf19 if}(state.A >= state.number_of_servers)\{\par
93                 fprintf(stderr, {\cf22 "O trafego oferecido nao pode ser maior ou igual que o numero de canais. Tem de alterar os valores de Mean_Interarrival e/ou Mean_Service. \\n"});\par
94                 something_wrong = 1;\par
95             \}\par
96 \par
97             {\cf19 if} (something_wrong == 1)\{ {\cf20 /* Just one of the parameters is not correct and the program ends */}\par
98                 exit(EXIT_FAILURE); \par
99             \}\par
100         \}\par
101 \par
102         {\cf20 /* Call the function and generate the remaining seeds */}\par
103         generate_other_streams(&state);\par
104 \par
105     \} {\cf19 else} \{\par
106      \par
107 {\cf21         #ifdef _WIN32}\par
108             system({\cf22 "cls"});\par
109 {\cf21         #else}\par
110             system({\cf22 "clear"});\par
111 {\cf21         #endif }\par
112 \par
113 \par
114 \par
115             {\cf19 do} \{\par
116                 printf({\cf22 "Number of servers -> "});\par
117                 {\cf19 if} (scanf({\cf22 "%d"}, &state.number_of_servers) != 1) \{  \par
118 {\cf21                 #ifdef _WIN32}\par
119                     system({\cf22 "cls"});\par
120 {\cf21                 #else}\par
121                     system({\cf22 "clear"});\par
122 {\cf21                 #endif}\par
123                     printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
124                     {\cf18 int} ch;\par
125                     {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF);\par
126                     state.number_of_servers = -1;\par
127                 \}\par
128             \} {\cf19 while}(state.number_of_servers <= 0 || state.number_of_servers>MAX_SERVERS);\par
129 \par
130 \par
131         {\cf19 do}\{\par
132 {\cf21             #ifdef _WIN32}\par
133                 system({\cf22 "cls"});\par
134 {\cf21             #else}\par
135                 system({\cf22 "clear"});\par
136 {\cf21             #endif }\par
137 \par
138             {\cf19 do} \{\par
139                 printf({\cf22 "\\nMean interarrival time -> "});\par
140                 {\cf19 if} (scanf({\cf22 "%f"}, &state.mean_interarrival) != 1) \{\par
141 \par
142 {\cf21                     #ifdef _WIN32}\par
143                         system({\cf22 "cls"});\par
144 {\cf21                     #else}\par
145                         system({\cf22 "clear"});\par
146 {\cf21                     #endif }\par
147 \par
148                     printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
149                     {\cf18 int} ch;\par
150                     {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF);  {\cf20 // Cleans the buffer}\par
151                     state.mean_interarrival = -1;  {\cf20 // Defines an invalid number to repeat the loop}\par
152                 \}\par
153                 \par
154                 {\cf19 if}(state.mean_interarrival <= 0 ) \{\par
155                     printf({\cf22 "O tempo medio entre chegadas nao pode ser negativo. \\n"});\par
156                 \}\par
157 \par
158             \} {\cf19 while}(state.mean_interarrival <= 0);\par
159 \par
160             {\cf19 do} \{\par
161                 printf({\cf22 "\\nMean service time -> "});\par
162                 {\cf19 if} (scanf({\cf22 "%f"}, &state.mean_service) != 1) \{ \par
163 {\cf21                     #ifdef _WIN32}\par
164                         system({\cf22 "cls"});\par
165 {\cf21                     #else}\par
166                         system({\cf22 "clear"});\par
167 {\cf21                     #endif}\par
168 \par
169                     printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
170                     {\cf18 int} ch;\par
171                     {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF);\par
172                     state.mean_service = -1;\par
173                 \}\par
174                 \par
175                 {\cf19 if}(state.mean_service <= 0) \{\par
176                     printf({\cf22 "O tempo medio de servico nao pode ser negativo. \\n"});\par
177                 \}\par
178 \par
179             \} {\cf19 while}(state.mean_service <= 0);\par
180             \par
181             state.A = 1/state.mean_interarrival * state.mean_service;\par
182 \par
183             {\cf19 if}(state.A >= state.number_of_servers)\{\par
184                 printf({\cf22 "O trafego oferecido nao pode ser maior ou igual que o numero de canais. Tem de alterar os valores de Mean_Interarrival e/ou Mean_Service. \\n"});\par
185             \}\par
186         \par
187         \} {\cf19 while}(state.A >= state.number_of_servers);\par
188         \par
189 \par
190 {\cf21         #ifdef _WIN32}\par
191             system({\cf22 "cls"});\par
192 {\cf21         #else}\par
193             system({\cf22 "clear"});\par
194 {\cf21         #endif }\par
195 \par
196 \par
197         {\cf19 do} \{\par
198             printf({\cf22 "Number of customers -> "});\par
199             {\cf19 if} (scanf({\cf22 "%d"}, &state.num_delays_required) != 1) \{ \par
200 \par
201 {\cf21             #ifdef _WIN32}\par
202                 system({\cf22 "cls"});\par
203 {\cf21             #else}\par
204                 system({\cf22 "clear"});\par
205 {\cf21             #endif}\par
206 \par
207                 printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
208                 {\cf18 int} ch;\par
209                 {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF);\par
210                 state.num_delays_required = -1;\par
211             \}\par
212         \} {\cf19 while}(state.num_delays_required <= 0);\par
213 \par
214 {\cf21         #ifdef _WIN32}\par
215             system({\cf22 "cls"});\par
216 {\cf21         #else}\par
217             system({\cf22 "clear"});\par
218 {\cf21         #endif }\par
219 \par
220     \par
221 \par
222         {\cf19 do} \{\par
223             printf({\cf22 "Without Queue = 0  ou Infinite Queue = 1 -> "});\par
224             {\cf19 if} (scanf({\cf22 "%d"}, &state.without_infinite_queue) != 1) \{  \par
225 {\cf21             #ifdef _WIN32}\par
226                 system({\cf22 "cls"});\par
227 {\cf21             #else}\par
228                 system({\cf22 "clear"});\par
229 {\cf21             #endif}\par
230                 printf({\cf22 "Por favor, insira um numero positivo.\\n"});\par
231                 {\cf18 int} ch;\par
232                 {\cf19 while} ((ch = getchar()) != {\cf23 '\\n'} && ch != EOF);\par
233                 state.num_delays_required = -1;\par
234       \}\par
235         \} {\cf19 while}(state.without_infinite_queue != 1 && state.without_infinite_queue != 0 );\par
236 \par
237         ask_streams(&state);\par
238 \par
239 {\cf21         #ifdef _WIN32}\par
240             system({\cf22 "cls"});\par
241 {\cf21         #else}\par
242             system({\cf22 "clear"});\par
243 {\cf21         #endif }\par
244 \par
245         generate_other_streams(&state);\par
246         \par
247 \par
248         files.infile = fopen({\cf22 "mm1in.txt"}, {\cf22 "w"});\par
249         fprintf(files.infile, {\cf22 "%.2f %.2f %d\\n"}, state.mean_interarrival, state.mean_service, state.num_delays_required);\par
250         fprintf(files.infile, {\cf22 "%d %d\\n"}, state.number_of_servers, state.without_infinite_queue);\par
251         fprintf(files.infile, {\cf22 "%d %d\\n"}, state.streams[0], state.streams[1]);\par
252     \}\par
253 \par
254     {\cf20 /* Prints all the parameters */}\par
255     printf({\cf22 "Mean interarrival time: %f\\n"}, state.mean_interarrival);\par
256     printf({\cf22 "Mean service time: %f\\n"}, state.mean_service);\par
257     printf({\cf22 "Number of customers: %d\\n"}, state.num_delays_required);\par
258     printf({\cf22 "Number of servers: %d\\n"}, state.number_of_servers);\par
259 \par
260     {\cf19 if}(state.without_infinite_queue == 0)\{\par
261         printf({\cf22 "Without Queue \\n"});\par
262     \}\par
263     {\cf19 else}\{\par
264         printf({\cf22 "Infinite Queue \\n"});\par
265     \}\par
266 \par
267 \par
268 \par
269     {\cf18 char} nome_saida[100];\par
270     {\cf19 while} (1) \{\par
271         printf({\cf22 "Escreva o ficheiro onde quer escrever o report (com extensao .txt): "});\par
272         scanf({\cf22 "%99s"}, nome_saida);  {\cf20 /* Reads the file name, limiting it to 99 characters */} \par
273 \par
274         {\cf20 /* Checks if the name ends with ".txt" */}\par
275         {\cf19 if} (strlen(nome_saida) > 4 && strcmp(nome_saida + strlen(nome_saida) - 4, {\cf22 ".txt"}) == 0) \{\par
276             {\cf19 break};  {\cf20 /* Exit the loop if the name ends with ".txt" */}\par
277         \} {\cf19 else} \{\par
278             printf({\cf22 "Erro: O nome do ficheiro deve terminar com '.txt'. Tente novamente.\\n"});\par
279         \}\par
280   \}\par
281 \par
282     files.outfile = fopen(nome_saida, {\cf22 "w"});\par
283     {\cf19 if} (!files.outfile) \{\par
284             perror({\cf22 "File opening failed"});\par
285             {\cf19 return} EXIT_FAILURE;\par
286   \}\par
287 \par
288 \par
289 \par
290     initialize(&state, &stats, &events, state.streams[0]);\par
291     \par
292 \par
293     {\cf19 while} (state.num_custs_delayed < state.num_delays_required) \{\par
294 \par
295 \par
296         timing(&state, &stats, &files, &events);\par
297         \par
298 \par
299         update_time_avg_stats(&state, &stats, &events);\par
300 \par
301 \par
302         {\cf19 switch} (state.next_event_type) \{\par
303             {\cf19 case} 1:\par
304                 arrive(&state, &stats, &files, &events);\par
305                 {\cf19 break};\par
306 \par
307             {\cf19 default}: {\cf20 /* Se o next_event_type estiver entre 2 e number_of_server+1 */}\par
308                 depart(&state, &stats, &events);\par
309                 {\cf19 break};\par
310         \}\par
311     \}\par
312 \par
313 \par
314     report(&state, &stats, &files, &events);\par
315     fclose(files.infile);\par
316     fclose(files.outfile);\par
317     \par
318     {\cf19 return} EXIT_SUCCESS;\par
319 \}\par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
